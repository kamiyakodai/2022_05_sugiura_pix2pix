# -*- coding: utf-8 -*-
"""multichannelConvert.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jao_rbWJPgiAo7SeULMA84CbiQvMdEp_
"""

import sys
import argparse
import os
import random
import time
import datetime
import numpy as np
import torch
from torch import nn
import torch.nn.functional as F
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
import torchvision.transforms as transforms
import torchvision.utils as vutils
from PIL import Image
import pickle

# 条件画像と正解画像のペアデータセット生成クラス


def labelSet(dir):
    #昇順
    #ラベル画像
    B_paths = sorted(makeDatasetB(dir))
    return B_paths


def isImageFilePng(fname):
    # 画像ファイルかどうかを返す
    #fnameに入っているものの末尾がext(ここではpngかjpg)なのかどうかを判断している．
    #一致しているなら，trueを返す．
    return fname.endswith('.png')


#ラベル画像データセット作成
def makeDatasetB(dir):

    images_label = []

    #ディレクトリの確認
    assert os.path.isdir(dir), '%s is not a valid directory' % dir

    #root:現在のディレクトリ
    # _:内包するディレクトリ
    #fnames:内包するファイル
    for root, _, fnames in sorted(os.walk(dir)):
        for fname in fnames:
            if isImageFilePng(fname):
                path = os.path.join(root, fname)
                images_label.append(path)

    return images_label

def getitem(dir):
    label_images = []

    # 学習用データ１つの生成
    # A(テンソル) : 条件画像
    # B(テンソル) : Aのペアとなるターゲット画像
    B_paths = labelSet(dir)
    for index in range(len(B_paths)):
        B_path = B_paths[index]
        #Image.open(a):aで指定した画像を開く
        #RGB画像に変換

        B = Image.open(B_path).convert('RGB')
        load_size = 286
        B = B.resize((load_size, load_size), Image.NEAREST)

        crop_size = 256
        B = B.resize((crop_size, crop_size), Image.NEAREST)

        #H*W*CをC*H*Wに．指定の仕方は，元の位置をどこに持っていくかになる．
        #Hについていうと，Hはもともと0番目にある．その0を持ってくるところに書く

        B = np.array(B)
        label_image = B.transpose(2, 0, 1)
        label_images.append(label_image)

    return label_images

def __len__(self):
    # 全画像ファイル数を返す
    return len(self.A_paths)


#RGB値とマッチしたときのインデックスを返す
def labelRGBValue(RGB_value):
    default_RGB_value = [
                        [255,85,0],
                        [255,170,0],
                        [0,85,255],
                        [0,0,255],
                        [0,0,170],
                        [170,255,85],
                        [170,0,0],
                        [0,170,255],
                        [255,255,0],
                        [85,255,170],
                        [255,0,0],
                        [0,255,255],
                        ]
    default_RGB_value = np.array(default_RGB_value)

    #print(RGB_value)
    label_index = 0
    for i in range(12):
      if np.array_equal(default_RGB_value[i],RGB_value):
        label_index = i

    #print(label_index)

    return label_index


#任意の位置のRGBの値を取得し，リストに追加
def getPixelRGBValue(H,W,label_image_numpy):
  RGB_value = np.zeros(3)

  for i in range(3):
    RGB_value[i] = label_image_numpy[i, H, W]

  return RGB_value


def calMultichannel(label_image_numpy):
  #縦，横のサイズを指定
  crop_size = 256

  #0で埋められた二次元ndarrayを用意．大きさは縦*横
  z = torch.zeros(12, crop_size, crop_size)

  for h in range(crop_size):
    for w in range(crop_size):
      RGB_value = getPixelRGBValue(h, w, label_image_numpy)
      label = labelRGBValue(RGB_value)

      if label == 0:
        z[0, h, w] = 1
      elif label == 1:
        z[1, h, w] = 1
      elif label == 2:
        z[2, h, w] = 1
      elif label == 3:
        z[3, h, w] = 1
      elif label == 4:
        z[4, h, w] = 1
      elif label == 5:
        z[5, h, w] = 1
      elif label == 6:
        z[6, h, w] = 1
      elif label == 7:
        z[7, h, w] = 1
      elif label == 8:
        z[8, h, w] = 1
      elif label == 9:
        z[9, h, w] = 1
      elif label == 10:
        z[10,h, w] = 1
      elif label == 11:
        z[11, h, w] = 1

  return z

def main():
    dir = '/mnt/HDD4TB-3/sugiura/pix2pix/datasets/facades/train'
    imgs_list = getitem(dir)
    mkdir_name = '/mnt/HDD4TB-3/sugiura/pix2pix/pickle_datasets_train'
    if not os.path.exists(mkdir_name):
        os.mkdir(mkdir_name)

    for index in range(len(imgs_list)):
        onehot_label_img = calMultichannel(imgs_list[index])

        pickle_name = 'img_numpy' + str(index) + '.pickle'
        pickle_path = os.path.join(mkdir_name, pickle_name)
        print(index)
        with open(pickle_path, mode='wb') as f:
            pickle.dump(onehot_label_img, f)


if __name__ == '__main__':
    main()